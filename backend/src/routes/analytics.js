// ================================
// ANALYTICS ROUTES - backend/src/routes/analytics.js
// Routes compl√®tes pour le syst√®me d'analytics
// ================================

const express = require('express');
const router = express.Router();
const prisma = require('../config/database');
const authMiddleware = require('../middleware/auth');
const AnalyticsService = require('../services/analyticsService');

// Toutes les routes n√©cessitent une authentification
router.use(authMiddleware);

// ================================
// üìä DASHBOARD ANALYTICS PRINCIPAL
// ================================

router.get('/dashboard', async (req, res) => {
  try {
    const userId = req.user.id;
    const { period = '30d' } = req.query;
    
    console.log(`üìä Analytics dashboard requested for user ${userId}, period: ${period}`);
    
    const now = new Date();
    const dateRange = getDateRange(period);
    
    // Calculer toutes les m√©triques en parall√®le pour optimiser les performances
    const [
      basicStats,
      earningsData,
      performanceMetrics,
      trustMetrics,
      predictions,
      insights
    ] = await Promise.all([
      AnalyticsService.calculateBasicStats(userId),
      AnalyticsService.calculateEarnings(userId, dateRange.start, dateRange.end),
      AnalyticsService.calculatePerformanceMetrics(userId, dateRange.start),
      AnalyticsService.calculateTrustMetrics(userId),
      AnalyticsService.calculatePredictions(userId),
      AnalyticsService.generatePersonalizedInsights(userId)
    ]);

    res.json({
      success: true,
      analytics: {
        // Statistiques de base
        basic: basicStats,
        
        // Donn√©es financi√®res
        earnings: earningsData,
        
        // M√©triques de performance
        performance: performanceMetrics,
        
        // M√©triques de confiance
        trust: trustMetrics,
        
        // Pr√©dictions IA
        predictions,
        
        // Insights personnalis√©s
        insights,
        
        // M√©tadonn√©es
        metadata: {
          lastUpdated: now,
          period: period,
          dataQuality: 'high',
          userId: userId
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur analytics dashboard:', error);
    res.status(500).json({ 
      error: 'Erreur lors du calcul des analytics',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// ================================
// üìà HISTORIQUE D√âTAILL√â DES TRANSACTIONS
// ================================

router.get('/transactions', async (req, res) => {
  try {
    const userId = req.user.id;
    const { 
      page = 1, 
      limit = 20, 
      type,        // 'sent', 'transported', 'all'
      status,      // 'completed', 'cancelled', 'all' 
      dateFrom,
      dateTo,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;

    console.log(`üìà Transactions requested for user ${userId}`);

    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Construction de la requ√™te avec filtres
    const whereConditions = buildTransactionFilters(userId, type, status, dateFrom, dateTo);
    
    // R√©cup√©rer les transactions avec d√©tails complets
    const [transactions, totalCount] = await Promise.all([
      prisma.item.findMany({
        where: whereConditions,
        include: {
          trip: {
            include: {
              user: {
                select: {
                  id: true, fullName: true, rating: true, 
                  totalRatings: true, profilePicture: true
                }
              }
            }
          },
          user: {
            select: {
              id: true, fullName: true, rating: true,
              totalRatings: true, profilePicture: true
            }
          },
          reviews: {
            include: {
              author: {
                select: { id: true, fullName: true, profilePicture: true }
              }
            }
          }
        },
        orderBy: { [sortBy]: sortOrder },
        take: parseInt(limit),
        skip: offset
      }),
      
      prisma.item.count({ where: whereConditions })
    ]);

    // Enrichir avec calculs financiers
    const enrichedTransactions = await enrichTransactionsWithFinancials(transactions);
    const summary = await calculateTransactionsSummary(whereConditions);

    res.json({
      success: true,
      data: {
        transactions: enrichedTransactions,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: totalCount,
          pages: Math.ceil(totalCount / parseInt(limit))
        },
        summary,
        filters: {
          type, status, dateFrom, dateTo, sortBy, sortOrder
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur transactions:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des transactions' 
    });
  }
});

// ================================
// üí∞ WALLET & PORTEFEUILLE D√âTAILL√â
// ================================

router.get('/wallet', async (req, res) => {
  try {
    const userId = req.user.id;
    const { period = '30d' } = req.query;

    console.log(`üí∞ Wallet data requested for user ${userId}`);

    const dateRange = getDateRange(period);
    
    // Calculs financiers d√©taill√©s
    const [
      balance,
      earnings,
      expenses,
      transactions,
      projections
    ] = await Promise.all([
      AnalyticsService.calculateCurrentBalance(userId),
      AnalyticsService.calculateEarningsBreakdown(userId, dateRange),
      AnalyticsService.calculateExpensesBreakdown(userId, dateRange),
      getRecentFinancialTransactions(userId, 10),
      AnalyticsService.calculateFinancialProjections(userId)
    ]);

    res.json({
      success: true,
      wallet: {
        // Solde actuel
        currentBalance: balance,
        
        // Revenus d√©taill√©s
        earnings: {
          total: earnings.total,
          breakdown: earnings.breakdown,
          trends: earnings.trends
        },
        
        // D√©penses d√©taill√©es
        expenses: {
          total: expenses.total,
          breakdown: expenses.breakdown,
          trends: expenses.trends
        },
        
        // Transactions r√©centes
        recentTransactions: transactions,
        
        // Projections
        projections: {
          nextMonth: projections.nextMonth,
          nextQuarter: projections.nextQuarter,
          confidence: projections.confidence
        },
        
        // M√©triques financi√®res
        metrics: {
          profitMargin: calculateProfitMargin(earnings.total, expenses.total),
          avgTransactionValue: earnings.avgTransactionValue || 0,
          growthRate: earnings.monthlyGrowthRate || 0
        },
        
        // M√©tadonn√©es
        metadata: {
          period,
          lastUpdated: new Date(),
          currency: 'EUR'
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur wallet:', error);
    res.status(500).json({ 
      error: 'Erreur lors du calcul du portefeuille' 
    });
  }
});

// ================================
// üéØ M√âTRIQUES DE PERFORMANCE PUBLIQUE
// ================================

router.get('/public-stats/:userId?', async (req, res) => {
  try {
    const targetUserId = req.params.userId || req.user.id;
    
    console.log(`üéØ Public stats requested for user ${targetUserId}`);

    // V√©rifier si l'utilisateur existe
    const targetUser = await prisma.user.findUnique({
      where: { id: targetUserId },
      select: { 
        id: true, fullName: true, rating: true, totalRatings: true,
        identityVerified: true, emailVerified: true, createdAt: true
      }
    });

    if (!targetUser) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    // Calculer les stats publiques (sans donn√©es sensibles)
    const [publicStats, badges, achievements] = await Promise.all([
      AnalyticsService.calculatePublicStats(targetUserId),
      AnalyticsService.calculateUserBadges(targetUserId),
      AnalyticsService.calculateAchievements(targetUserId)
    ]);

    res.json({
      success: true,
      publicProfile: {
        user: targetUser,
        stats: publicStats,
        badges,
        achievements,
        isOwnProfile: targetUserId === req.user.id
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur stats publiques:', error);
    res.status(500).json({ 
      error: 'Erreur lors du calcul des statistiques publiques' 
    });
  }
});

// ================================
// üìä TRACKING D'√âV√âNEMENTS (Analytics Comportementales)
// ================================

router.post('/events', async (req, res) => {
  try {
    const userId = req.user.id;
    const { 
      eventType, 
      eventData = {}, 
      page, 
      timestamp = new Date(),
      sessionId,
      metadata = {}
    } = req.body;

    // Validation des √©v√©nements autoris√©s
    const allowedEvents = [
      'page_view', 'click', 'search', 'filter', 'sort',
      'create_trip', 'create_parcel', 'send_message',
      'view_profile', 'bookmark', 'share', 'error',
      'login', 'logout', 'payment', 'review_submit'
    ];

    if (!allowedEvents.includes(eventType)) {
      return res.status(400).json({ 
        error: 'Type d\'√©v√©nement non autoris√©',
        allowedEvents 
      });
    }

    // Stocker l'√©v√©nement
    const eventRecord = await AnalyticsService.logUserEvent({
      userId,
      eventType,
      eventData,
      page,
      timestamp: new Date(timestamp),
      sessionId,
      userAgent: req.headers['user-agent'],
      ipAddress: req.ip,
      metadata
    });

    // Mettre √† jour les m√©triques en temps r√©el si n√©cessaire
    await AnalyticsService.updateRealTimeMetrics(userId, eventType, eventData);

    res.json({ 
      success: true, 
      tracked: true,
      eventId: eventRecord.id || 'tracked'
    });

  } catch (error) {
    console.error('‚ùå Erreur tracking √©v√©nement:', error);
    // Ne pas faire √©chouer la requ√™te pour le tracking
    res.json({ 
      success: false, 
      tracked: false,
      error: 'Event tracking failed'
    });
  }
});

// ================================
// üîç INSIGHTS & RECOMMANDATIONS IA
// ================================

router.get('/insights', async (req, res) => {
  try {
    const userId = req.user.id;
    
    console.log(`üîç Insights requested for user ${userId}`);

    const insights = await AnalyticsService.generatePersonalizedInsights(userId);
    
    res.json({
      success: true,
      insights: {
        // Recommandations de pricing
        pricing: insights.pricing,
        
        // Opportunit√©s de routes
        routes: insights.routes,
        
        // Optimisations temporelles
        timing: insights.timing,
        
        // Am√©liorations profil
        profile: insights.profile,
        
        // Pr√©dictions march√©
        market: insights.market,
        
        // Plan d'action personnalis√©
        actionPlan: insights.actionPlan || [],
        
        // M√©tadonn√©es
        metadata: {
          generatedAt: new Date(),
          confidence: insights.confidence || 'medium',
          dataPoints: insights.dataPoints || 0
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erreur insights:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la g√©n√©ration des insights' 
    });
  }
});

// ================================
// üì± ANALYTICS OPTIMIS√âES MOBILE
// ================================

router.get('/mobile', async (req, res) => {
  try {
    const userId = req.user.id;
    
    console.log(`üì± Mobile analytics requested for user ${userId}`);

    // Version all√©g√©e pour mobile
    const mobileAnalytics = await AnalyticsService.getMobileOptimizedAnalytics(userId);

    res.json({
      success: true,
      mobile: true,
      analytics: mobileAnalytics
    });

  } catch (error) {
    console.error('‚ùå Erreur analytics mobile:', error);
    res.status(500).json({ 
      error: 'Erreur lors du calcul des analytics mobile' 
    });
  }
});

// ================================
// üìä EXPORT DE DONN√âES
// ================================

router.get('/export', async (req, res) => {
  try {
    const userId = req.user.id;
    const { format = 'json', period = '30d' } = req.query;

    console.log(`üìä Data export requested for user ${userId}, format: ${format}`);

    const dateRange = getDateRange(period);
    
    // R√©cup√©rer toutes les donn√©es pour export
    const exportData = await AnalyticsService.generateExportData(userId, dateRange);

    if (format === 'csv') {
      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="cheapship-analytics-${userId}-${period}.csv"`);
      res.send(convertToCSV(exportData));
    } else {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="cheapship-analytics-${userId}-${period}.json"`);
      res.json({
        success: true,
        export: exportData,
        metadata: {
          userId,
          period,
          exportedAt: new Date(),
          format
        }
      });
    }

  } catch (error) {
    console.error('‚ùå Erreur export:', error);
    res.status(500).json({ 
      error: 'Erreur lors de l\'export des donn√©es' 
    });
  }
});

// ================================
// üöÄ FONCTIONS UTILITAIRES
// ================================

function getDateRange(period) {
  const end = new Date();
  const start = new Date();
  
  switch (period) {
    case '7d':
      start.setDate(start.getDate() - 7);
      break;
    case '30d':
      start.setDate(start.getDate() - 30);
      break;
    case '90d':
      start.setDate(start.getDate() - 90);
      break;
    case '1y':
      start.setFullYear(start.getFullYear() - 1);
      break;
    default:
      start.setDate(start.getDate() - 30);
  }
  
  return { start, end };
}

function buildTransactionFilters(userId, type, status, dateFrom, dateTo) {
  const baseCondition = {
    OR: [
      { userId }, // Colis envoy√©s par l'utilisateur
      { trip: { userId } } // Colis transport√©s par l'utilisateur
    ]
  };

  // Filtrer par type
  if (type === 'sent') {
    baseCondition.OR = [{ userId }];
  } else if (type === 'transported') {
    baseCondition.OR = [{ trip: { userId } }];
  }

  // Filtrer par statut
  if (status && status !== 'all') {
    baseCondition.status = status.toUpperCase();
  }

  // Filtrer par dates
  if (dateFrom || dateTo) {
    baseCondition.createdAt = {};
    if (dateFrom) {
      baseCondition.createdAt.gte = new Date(dateFrom);
    }
    if (dateTo) {
      baseCondition.createdAt.lte = new Date(dateTo);
    }
  }

  return baseCondition;
}

async function enrichTransactionsWithFinancials(transactions) {
  return transactions.map(transaction => ({
    ...transaction,
    financials: {
      revenue: transaction.trip ? 
        (transaction.weight * transaction.trip.pricePerKg) : 0,
      commission: transaction.trip ? 
        (transaction.weight * transaction.trip.pricePerKg * 0.15) : 0,
      net: transaction.trip ? 
        (transaction.weight * transaction.trip.pricePerKg * 0.85) : 0
    }
  }));
}

async function calculateTransactionsSummary(whereConditions) {
  const [total, completed, cancelled] = await Promise.all([
    prisma.item.count({ where: whereConditions }),
    prisma.item.count({ 
      where: { ...whereConditions, status: 'DELIVERED' }
    }),
    prisma.item.count({ 
      where: { ...whereConditions, status: 'CANCELLED' }
    })
  ]);

  return {
    total,
    completed,
    cancelled,
    pending: total - completed - cancelled,
    successRate: total > 0 ? (completed / total) * 100 : 0
  };
}

async function getRecentFinancialTransactions(userId, limit) {
  return await prisma.item.findMany({
    where: {
      OR: [
        { userId },
        { trip: { userId } }
      ],
      status: 'DELIVERED'
    },
    include: {
      trip: {
        select: {
          pricePerKg: true,
          departureCity: true,
          arrivalCity: true
        }
      }
    },
    orderBy: { updatedAt: 'desc' },
    take: limit
  });
}

function calculateProfitMargin(earnings, expenses) {
  if (earnings === 0) return 0;
  return ((earnings - expenses) / earnings) * 100;
}

function convertToCSV(data) {
  // Fonction simple de conversion JSON vers CSV
  if (!data || data.length === 0) return '';
  
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => 
        JSON.stringify(row[header] || '')
      ).join(',')
    )
  ].join('\n');
  
  return csvContent;
}

module.exports = router;